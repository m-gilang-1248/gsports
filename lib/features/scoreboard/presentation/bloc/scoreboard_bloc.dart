import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:injectable/injectable.dart';
import 'package:gsports/features/scoreboard/domain/entities/match_result.dart';
import 'package:gsports/features/scoreboard/domain/entities/match_set.dart';
import 'package:gsports/features/scoreboard/domain/repositories/scoreboard_repository.dart';

part 'scoreboard_event.dart';
part 'scoreboard_state.dart';

@injectable
class ScoreboardBloc extends Bloc<ScoreboardEvent, ScoreboardState> {
  final ScoreboardRepository repository;

  ScoreboardBloc(this.repository) : super(const ScoreboardState()) {
    on<IncrementScoreA>(_onIncrementScoreA);
    on<IncrementScoreB>(_onIncrementScoreB);
    on<UndoLastAction>(_onUndoLastAction);
    on<ResetMatch>(_onResetMatch);
    on<SaveMatchRequested>(_onSaveMatchRequested);
  }

  void _onIncrementScoreA(
    IncrementScoreA event,
    Emitter<ScoreboardState> emit,
  ) {
    if (state.isMatchFinished) return;
    _saveStateForUndo(emit);
    _processScore(emit, state.scoreA + 1, state.scoreB, true);
  }

  void _onIncrementScoreB(
    IncrementScoreB event,
    Emitter<ScoreboardState> emit,
  ) {
    if (state.isMatchFinished) return;
    _saveStateForUndo(emit);
    _processScore(emit, state.scoreA, state.scoreB + 1, false);
  }

  void _processScore(
    Emitter<ScoreboardState> emit,
    int newScoreA,
    int newScoreB,
    bool isTeamA,
  ) {
    // Check Set Win Condition
    bool setWon = false;

    if ((newScoreA >= 21 || newScoreB >= 21)) {
      if ((newScoreA - newScoreB).abs() >= 2) {
        setWon = true;
      } else if (newScoreA == 30 || newScoreB == 30) {
        setWon = true;
      }
    }

    if (setWon) {
      final finishedSet = MatchSet(scoreA: newScoreA, scoreB: newScoreB);
      final newHistory = List<MatchSet>.from(state.historySets)
        ..add(finishedSet);

      // Check Match Win Condition (Best of 3)
      int winsA = newHistory.where((s) => s.scoreA > s.scoreB).length;
      int winsB = newHistory.where((s) => s.scoreB > s.scoreA).length;

      if (winsA == 2 || winsB == 2) {
        emit(
          state.copyWith(
            scoreA: newScoreA,
            scoreB: newScoreB,
            historySets: newHistory,
            isMatchFinished: true,
            winner: winsA == 2 ? 'Team A' : 'Team B',
          ),
        );
      } else {
        // Start Next Set
        emit(
          state.copyWith(
            scoreA: 0, // Reset scores for new set
            scoreB: 0,
            currentSet: state.currentSet + 1,
            historySets: newHistory,
          ),
        );
      }
    } else {
      // Just update score
      emit(state.copyWith(scoreA: newScoreA, scoreB: newScoreB));
    }
  }

  void _saveStateForUndo(Emitter<ScoreboardState> emit) {
    // Limit stack size if needed, e.g., max 10
    final newStack = List<ScoreboardState>.from(state.undoStack)..add(state);
    emit(state.copyWith(undoStack: newStack));
  }

  void _onUndoLastAction(UndoLastAction event, Emitter<ScoreboardState> emit) {
    if (state.undoStack.isNotEmpty) {
      final previousState = state.undoStack.last;
      final newStack = List<ScoreboardState>.from(state.undoStack)
        ..removeLast();

      // Restore state but update the stack
      emit(previousState.copyWith(undoStack: newStack));
    }
  }

  void _onResetMatch(ResetMatch event, Emitter<ScoreboardState> emit) {
    emit(const ScoreboardState());
  }

  Future<void> _onSaveMatchRequested(
    SaveMatchRequested event,
    Emitter<ScoreboardState> emit,
  ) async {
    if (!state.isMatchFinished) return;

    final match = MatchResult(
      id: '', // Generated by Firestore
      bookingId: event.bookingId,
      sportType: event.sportType,
      playedAt: DateTime.now(),
      sets: state.historySets,
      winner: state.winner!,
    );

    await repository.saveMatch(match);
    // Ideally emit a success/failure state or use a side-effect
  }
}
